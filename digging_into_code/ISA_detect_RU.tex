\mysection{Определение \ac{ISA}}
\label{ISA_detect}

Часто, вы можете иметь дело с бинарным файлом для неизвестной \ac{ISA}.
Вероятно, простейший способ определить \ac{ISA} это пробовать разные в IDA, objdump или другом дизассемблере.

Чтобы этого достичь, нужно понимать разницу между некорректно дизассемблированным кодом, и корректно дизассемблированным.

% subsection:
\renewcommand{\CURPATH}{digging_into_code/incorrect_disassembly}
\input{digging_into_code/incorrect_disassembly/main_RU}

\subsection{Корректино дизассемблированный код}
\label{correctly_disasmed_code}

Каждая \ac{ISA} имеет десяток самых используемых инструкций, остальные используются куда реже.

Интересно знать тот факт, что в x86, инструкции вызовов ф-ций (\PUSH/\CALL/\ADD) и \MOV
это наиболее часто исполняющиеся инструкции в коде почти во всем ПО что мы используем.
Другими словами, \ac{CPU} очень занят передачей информации между уровнями абстракции, или, можно сказать, очень занят
переключением между этими уровнями.
Вне зависимости от \ac{ISA}.
Это цена расслоения программ на разные уровни абстракций (чтобы человеку было легче с ними управляться).

