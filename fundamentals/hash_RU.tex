% TODO TikZ
\newcommand{\HashFuncChapterName}{Хеш-функции}
\mysection{\HashFuncChapterName}
\label{hash_func}

\myindex{\HashFuncChapterName}
\myindex{CRC32}
Простейший пример это CRC32, алгоритм \q{более мощный} чем простая контрольная сумма,
для проверки целостности данных.
Невозможно восстановить оригинальный текст из хеша, там просто меньше информации: ведь текст
может быть очень длинным, но результат CRC32 всегда ограничен 32 битами.
Но CRC32 не надежна в криптографическом смысле: известны методы как изменить текст таким образом,
чтобы получить нужный результат.
Криптографические хеш-функции защищены от этого. \\
\\
\myindex{MD5}
\myindex{SHA1}
Такие функции как MD5, SHA1, итд, широко используются для хеширования паролей
для хранения их в базе.
Действительно: БД форума в интернете может и не хранить пароли 
(иначе злоумышленник получивший доступ к БД сможет узнать все пароли), а только хеши.
К тому же, скрипту интернет-форума вовсе не обязательно знать ваш пароль, он только должен
сверить его хеш с тем что лежит в БД, и дать вам доступ если cверка проходит.
Один из самых простых способов взлома --- это просто перебирать все пароли и ждать пока
результат будет такой же как тот что нам нужен.
Другие методы намного сложнее.
% TODO1 add about Rainbow tables

\subsection{Как работает односторонняя функция?}

Односторонняя функция, это функция, которая способна превратить из одного значения другое,
при этом невозможно (или трудно) проделать обратную операцию.
Некоторые люди имеют трудности с пониманием, как это возможно.
Рассмотрим очень простой пример.

У нас есть ряд из 10-и чисел в пределах 0..9, каждое встречается один раз, например:

\begin{lstlisting}
4 6 0 1 3 5 7 8 9 2
\end{lstlisting}

Алгоритм простейшей односторонней функции выглядит так:

\begin{itemize}
\item возьми число на нулевой позиции (у нас это 4);
\item возьми число на первой позиции (у нас это 6);
\item обменяй местами числа на позициях 4 и 6.
\end{itemize}

Отметим числа на позициях 4 и 6:

\begin{lstlisting}
4 6 0 1 3 5 7 8 9 2
        ^   ^
\end{lstlisting}

Меняем их местами и получаем результат:

\begin{lstlisting}
4 6 0 1 7 5 3 8 9 2
\end{lstlisting}

Глядя на результат, и даже зная алгоритм функции, мы не можем однозначно восстановить изначальное
положение чисел.
Ведь первые два числа могли быть 0 и/или 1, и тогда именно они могли бы участвовать в обмене.

Это крайне упрощенный пример для демонстрации, настоящие односторонние функции могут быть значительно сложнее.
