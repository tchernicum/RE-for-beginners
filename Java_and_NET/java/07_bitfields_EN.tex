% TODO proof-reading
\subsection{Bitfields}

All bit-wise operations work just like in any other \ac{ISA}:


\begin{lstlisting}[style=customjava]
	public static int set (int a, int b) 
	{
		return a | 1<<b;
	}

	public static int clear (int a, int b) 
	{
		return a & (~(1<<b));
	}
\end{lstlisting}

\begin{lstlisting}
  public static int set(int, int);
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=2, args_size=2
         0: iload_0       
         1: iconst_1      
         2: iload_1       
         3: ishl          
         4: ior           
         5: ireturn       

  public static int clear(int, int);
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=2, args_size=2
         0: iload_0       
         1: iconst_1      
         2: iload_1       
         3: ishl          
         4: iconst_m1     
         5: ixor          
         6: iand          
         7: ireturn       
\end{lstlisting}

\TT{iconst\_m1} loads $-1$ in the stack, it's the same as the \TT{0xFFFFFFFF} number.

XORing with \TT{0xFFFFFFFF} has the same effect of inverting all bits
 (\myref{XOR_property}).

Let's extend all data types to 64-bit \emph{long}:


\begin{lstlisting}[style=customjava]
	public static long lset (long a, int b) 
	{
		return a | 1<<b;
	}

	public static long lclear (long a, int b) 
	{
		return a & (~(1<<b));
	}
\end{lstlisting}

\begin{lstlisting}
  public static long lset(long, int);
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=4, locals=3, args_size=2
         0: lload_0       
         1: iconst_1      
         2: iload_2       
         3: ishl          
         4: i2l           
         5: lor           
         6: lreturn       

  public static long lclear(long, int);
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=4, locals=3, args_size=2
         0: lload_0       
         1: iconst_1      
         2: iload_2       
         3: ishl          
         4: iconst_m1     
         5: ixor          
         6: i2l           
         7: land          
         8: lreturn       
\end{lstlisting}

The code is the same, but instructions with \emph{l} prefix are used, which operate 
on 64-bit values.

Also, the second argument of the function still is of type \emph{int}, and when the 32-bit value in it 
needs to be promoted to 64-bit value the \TT{i2l} instruction is used, 
which essentially extend the value of an \emph{integer} type to a \emph{long} one.

