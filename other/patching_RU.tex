\mysection{Модификация исполняемых файлов}

\subsection{Текстовые строки}

Сишные строки проще всего модифицировать (если они не зашифрованы) в любом шестнадцатеричном редакторе.
Эта техника доступна даже для тех, кто вовсе не разбирается в машинном коде и форматах исполняемых
файлов.
Новая строка не должна быть длиннее старой, потому что имеется риск затереть какую-то другую переменную
или код.
\myindex{MS-DOS}
Используя этот метод, очень много ПО было \emph{локализовано} во времена MS-DOS, как минимум,
в странах бывшего СССР, в 80-х и 90-х.
Отсюда наличие очень странных аббревиатур и сокращений в \emph{локализованном} ПО: 
там просто не было места для более
длинных строк.

\myindex{Borland Delphi}
В строках в Delphi, длина строки также должна быть поправлена, если нужно.

\subsection{x86-код}
\label{x86_patching}

Часто необходимые задачи:

\myindex{x86!\Instructions!NOP}
\begin{itemize}

\item Часто нужно просто запретить исполнение какой-либо инструкции.
И чаще всего, это можно сделать, заполняя её байтом 
\TT{0x90} (\ac{NOP}).

\item Условные переходы, имеющие опкод вроде \TT{74 xx} (\JZ), 
так же могут быть заполнены двумя \ac{NOP}-ами.
Также возможно запретить исполнение условного перехода записав 0 во второй байт (\emph{jump offset}).

\myindex{x86!\Instructions!JMP}
\item Еще одна часто необходимая задача это сделать условный переход всегда срабатывающим: 
это возможно при помощи записи \TT{0xEB} 
вместо опкода, это значит \JMP.

\myindex{x86!\Instructions!RET}
\myindex{stdcall}
\item Исполнение функции может быть запрещено, если записать
\RETN (0xC3) в её начале.
Это справедливо для всех функций кроме \TT{stdcall} 
(\myref{sec:stdcall}).
При модификации функций \TT{stdcall}, нужно в начале определить количество аргументов 
(например, отыскав \RETN в этой функции),
и использовать \RETN с 16-битным аргументом (0xC2).

\myindex{x86!\Instructions!MOV}
\myindex{x86!\Instructions!XOR}
\myindex{x86!\Instructions!INC}
\item Иногда, запрещенная функция должна возвращать 0 или 1.
Это можно сделать при помощи \TT{MOV EAX, 0} или \TT{MOV EAX, 1}, 
но это слишком многословно.\\
Способ получше это \TT{XOR EAX, EAX} (2 байта \TT{0x31 0xC0}) или \TT{XOR EAX, EAX / INC EAX} (3 байта \TT{0x31 0xC0 0x40}).

\end{itemize}

ПО может быть защищено от модификаций.
Эта защита чаще всего реализуется путем чтения кода и вычисления контрольной суммы.
Следовательно, код должен быть прочитан перед тем как защита сработает.
Это можно определить установив точку останова на чтение памяти.

\myindex{tracer}
В \tracer имеется опция BPM для этого.

Релоки в исполняемых PE-файлах (\myref{subsec:relocs}) 
не должны быть тронуты, потому что загрузчик Windows перезапишет ваш новый код.

\myindex{Hiew}
(Они выделяются серым в Hiew, например: \figref{fig:scanf_ex3_hiew_1}).
В качестве последней меры, можно записать \JMP для обхода релока, либо же придется модифицировать таблицу
релоков.


