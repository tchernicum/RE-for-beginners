\subsubsection{MIPS}
% FIXME better start at non-optimizing version?
Функция использует много S-регистров, которые должны быть сохранены. Вот почему их значения сохраняются
в прологе функции и восстанавливаются в эпилоге.

\lstinputlisting[caption=\Optimizing GCC 4.4.5 (IDA),style=customasmMIPS]{patterns/13_arrays/1_simple/MIPS_O3_IDA_RU.lst}

Интересная вещь: здесь два цикла и в первом не нужна переменная $i$, а нужна только переменная
$i*2$ (скачущая через 2 на каждой итерации) и ещё адрес в памяти (скачущий через 4 на каждой итерации).

Так что мы видим здесь две переменных: одна (в \$V0) увеличивается на 2 каждый раз, и вторая (в \$V1) --- на 4.

Второй цикл содержит вызов \printf. Он должен показывать значение $i$ пользователю,
поэтому здесь есть переменная, увеличивающаяся на 1 каждый раз (в \$S0), а также адрес в памяти (в \$S1) 
увеличивающийся на 4 каждый раз.

Это напоминает нам оптимизацию циклов: \myref{loop_iterators}.
Цель оптимизации в том, чтобы избавиться от операций умножения.

