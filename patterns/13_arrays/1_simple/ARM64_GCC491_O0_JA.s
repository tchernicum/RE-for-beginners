.LC0:
	.string	"a[%d]=%d\n"
main:
; スタックフレームにFPとLRを保存
	stp	x29, x30, [sp, -112]!
; スタックフレームを設定 (FP=SP)
	add	x29, sp, 0
; 初期カウンタ値を0に設定（WZRは常に0を保持するレジスタ）
	str	wzr, [x29,108]
; ループ条件チェックコードにジャンプ
	b	.L2
.L3:
; "i"変数の値をロード
	ldr	w0, [x29,108]
; 2倍する
	lsl	w2, w0, 1
; ローカルスタックの配列の位置を見つける
	add	x0, x29, 24
; ローカルスタックから符号なし32ビットをロードし、64ビットの符号付き値へ拡張
	ldrsw	x1, [x29,108]
; 要素のアドレスを計算(X0+X1<<2=array address+i*4)し、そこにW2 (i*2) を保存
	str	w2, [x0,x1,lsl 2]
; カウンタ(i)をインクリメント
	ldr	w0, [x29,108]
	add	w0, w0, 1
	str	w0, [x29,108]
.L2:
; 終了かをチェック
	ldr	w0, [x29,108]
	cmp	w0, 19
; 終了でなければL3にジャンプ（ループボディの開始）
	ble	.L3
; 関数の第二部がここから始まる
; 初期カウンタ変数を0に設定
; ところで、ローカルスタックの同じ場所がカウンタとして使用されます
; 同じローカル変数(i)がカウンタとして使用されるからです
	str	wzr, [x29,108]
	b	.L4
.L5:
; 配列のアドレスを計算
	add	x0, x29, 24
; "i"値をロード
	ldrsw	x1, [x29,108]
; アドレス(X0+X1<<2 = address of array + i*4)の配列から値をロード
	ldr	w2, [x0,x1,lsl 2]
; \verb|"a[%d]=%d\n"|文字列のアドレスをロード
	adrp	x0, .LC0
	add	x0, x0, :lo12:.LC0
; "i"変数をW1にロードし、printf()の第二引数として渡す
	ldr	w1, [x29,108]
; W2はロードされた配列要素の値を保持
; printf()を呼び出す
	bl	printf
; "i"変数をインクリメント
	ldr	w0, [x29,108]
	add	w0, w0, 1
	str	w0, [x29,108]
.L4:
; 終了した？
	ldr	w0, [x29,108]
	cmp	w0, 19
; 終了していなければループボディの開始にジャンプ
	ble	.L5
; 0をリターン
	mov	w0, 0
; FPとLRを戻す
	ldp	x29, x30, [sp], 112
	ret
