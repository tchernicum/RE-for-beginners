.LC0:
	.string	"a[%d]=%d\n"
main:
; сохранить FP и LR в стековом фрейме:
	stp	x29, x30, [sp, -112]!
; установить стековый фрейм (FP=SP)
	add	x29, sp, 0
; установить начальное значение счетчика в 0 (WZR это регистр всегда содержащий ноль):
	str	wzr, [x29,108]
; перейти на код проверки условия цикла:
	b	.L2
.L3:
; загрузить значение переменной "i":
	ldr	w0, [x29,108]
; умножить на 2:
	lsl	w2, w0, 1
; найти место массива в локальном стеке:
	add	x0, x29, 24
; загрузить 32-битное число из локального стека и расширить его до 64-битного учитывая знак:
	ldrsw	x1, [x29,108]
; вычислить адрес элемента (X0+X1<<2=array address+i*4) и записать W2 (i*2) там:
	str	w2, [x0,x1,lsl 2]
; инкремент счетчика (i):
	ldr	w0, [x29,108]
	add	w0, w0, 1
	str	w0, [x29,108]
.L2:
; проверить, закончили ли:
	ldr	w0, [x29,108]
	cmp	w0, 19
; перейти на L3 (начало тела цикла), если нет:
	ble	.L3
; здесь начинается вторая часть функции.
; устанавливаем первичного значение счетчика в 0.
; кстати, это же место в локальном стеке было уже использовано под счетчик
; потому что та же локальная переменная (i) используется как счетчик.
	str	wzr, [x29,108]
	b	.L4
.L5:
; вычислить адрес массива:
	add	x0, x29, 24
; загрузить переменную "i":
	ldrsw	x1, [x29,108]
; загрузить значение из массива по адресу (X0+X1<<2 = адрес массива + i*4)
	ldr	w2, [x0,x1,lsl 2]
; загрузить адрес строки \verb|"a[%d]=%d\n"|:
	adrp	x0, .LC0
	add	x0, x0, :lo12:.LC0
; загрузить переменную "i" в W1 и передать её в printf() как второй аргумент:
	ldr	w1, [x29,108]
; W2 всё еще содержит загруженный элемент из массива.
; вызов printf():
	bl	printf
; инкремент переменной "i":
	ldr	w0, [x29,108]
	add	w0, w0, 1
	str	w0, [x29,108]
.L4:
; закончили?
	ldr	w0, [x29,108]
	cmp	w0, 19
; перейти на начало тела цикла, если нет:
	ble	.L5
; возврат 0
	mov	w0, 0
; восстановить FP и LR:
	ldp	x29, x30, [sp], 112
	ret
