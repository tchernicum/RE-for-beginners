\subsection{Подсчет выставленных бит}

Вот этот несложный пример иллюстрирует функцию, считающую количество бит-единиц во входном значении.

Эта операция также называется \q{population count}\footnote{современные x86-процессоры (поддерживающие SSE4) даже имеют инструкцию POPCNT для этого}.

\lstinputlisting[style=customc]{patterns/14_bitfields/4_popcnt/shifts.c}

В этом цикле счетчик итераций $i$ считает от 0 до 31, а $1 \ll i$ будет от 1 до \TT{0x80000000}. 
Описывая это словами, можно сказать 
\emph{сдвинуть единицу на $n$ бит влево}.
Т.е. в некотором смысле, выражение $1 \ll i$ последовательно выдает все возможные позиции бит в 32-битном числе. 
Освободившийся бит справа всегда обнуляется.

Вот таблица всех возможных значений $1 \ll i$ для $i=0 \ldots 31$:

%\small
\label{2n_numbers_table}
\begin{center}
\begin{tabular}{ | l | l | l | l | }
\hline
\HeaderColor Выражение & 
\HeaderColor Степень двойки & 
\HeaderColor Десятичная форма & 
\HeaderColor Шестнадцатеричная \\
\hline
$1 \ll 0$ & $2^{0}$ & 1 & 1 \\
\hline
$1 \ll 1$ & $2^{1}$ & 2 & 2 \\
\hline
$1 \ll 2$ & $2^{2}$ & 4 & 4 \\
\hline
$1 \ll 3$ & $2^{3}$ & 8 & 8 \\
\hline
$1 \ll 4$ & $2^{4}$ & 16 & 0x10 \\
\hline
$1 \ll 5$ & $2^{5}$ & 32 & 0x20 \\
\hline
$1 \ll 6$ & $2^{6}$ & 64 & 0x40 \\
\hline
$1 \ll 7$ & $2^{7}$ & 128 & 0x80 \\
\hline
$1 \ll 8$ & $2^{8}$ & 256 & 0x100 \\
\hline
$1 \ll 9$ & $2^{9}$ & 512 & 0x200 \\
\hline
$1 \ll 10$ & $2^{10}$ & 1024 & 0x400 \\
\hline
$1 \ll 11$ & $2^{11}$ & 2048 & 0x800 \\
\hline
$1 \ll 12$ & $2^{12}$ & 4096 & 0x1000 \\
\hline
$1 \ll 13$ & $2^{13}$ & 8192 & 0x2000 \\
\hline
$1 \ll 14$ & $2^{14}$ & 16384 & 0x4000 \\
\hline
$1 \ll 15$ & $2^{15}$ & 32768 & 0x8000 \\
\hline
$1 \ll 16$ & $2^{16}$ & 65536 & 0x10000 \\
\hline
$1 \ll 17$ & $2^{17}$ & 131072 & 0x20000 \\
\hline
$1 \ll 18$ & $2^{18}$ & 262144 & 0x40000 \\
\hline
$1 \ll 19$ & $2^{19}$ & 524288 & 0x80000 \\
\hline
$1 \ll 20$ & $2^{20}$ & 1048576 & 0x100000 \\
\hline
$1 \ll 21$ & $2^{21}$ & 2097152 & 0x200000 \\
\hline
$1 \ll 22$ & $2^{22}$ & 4194304 & 0x400000 \\
\hline
$1 \ll 23$ & $2^{23}$ & 8388608 & 0x800000 \\
\hline
$1 \ll 24$ & $2^{24}$ & 16777216 & 0x1000000 \\
\hline
$1 \ll 25$ & $2^{25}$ & 33554432 & 0x2000000 \\
\hline
$1 \ll 26$ & $2^{26}$ & 67108864 & 0x4000000 \\
\hline
$1 \ll 27$ & $2^{27}$ & 134217728 & 0x8000000 \\
\hline
$1 \ll 28$ & $2^{28}$ & 268435456 & 0x10000000 \\
\hline
$1 \ll 29$ & $2^{29}$ & 536870912 & 0x20000000 \\
\hline
$1 \ll 30$ & $2^{30}$ & 1073741824 & 0x40000000 \\
\hline
$1 \ll 31$ & $2^{31}$ & 2147483648 & 0x80000000 \\
\hline
\end{tabular}
\end{center}
%\normalsize

Это числа-константы (битовые маски), которые крайне часто попадаются в практике reverse engineer-а, 
и их нужно уметь распознавать.

Числа в десятичном виде, до 65536 и числа в шестнадцатеричном виде легко запомнить и так.
А числа в десятичном виде после 65536, пожалуй, заучивать не нужно.

Эти константы очень часто используются для определения отдельных бит как флагов.

Например, это из файла \TT{ssl\_private.h} из исходников Apache 2.4.6:

\begin{lstlisting}[style=customc]
/**
 * Define the SSL options
 */
#define SSL_OPT_NONE           (0)
#define SSL_OPT_RELSET         (1<<0)
#define SSL_OPT_STDENVVARS     (1<<1)
#define SSL_OPT_EXPORTCERTDATA (1<<3)
#define SSL_OPT_FAKEBASICAUTH  (1<<4)
#define SSL_OPT_STRICTREQUIRE  (1<<5)
#define SSL_OPT_OPTRENEGOTIATE (1<<6)
#define SSL_OPT_LEGACYDNFORMAT (1<<7)
\end{lstlisting}

Вернемся назад к нашему примеру.

Макрос \TT{IS\_SET} проверяет наличие этого бита в $a$.

\myindex{x86!\Instructions!AND}
Макрос \TT{IS\_SET} на самом деле это операция логического И (\emph{AND}) 
и она возвращает 0 если бита там нет, 
либо эту же битовую маску, если бит там есть. 
В \CCpp, конструкция \TT{if()} срабатывает, если выражение внутри её не ноль, пусть хоть 123456, 
поэтому все будет работать.

% subsections

\input{patterns/14_bitfields/4_popcnt/x86_RU}
\input{patterns/14_bitfields/4_popcnt/x64_RU}
\input{patterns/14_bitfields/4_popcnt/ARM_RU}
\input{patterns/14_bitfields/4_popcnt/MIPS_RU}

