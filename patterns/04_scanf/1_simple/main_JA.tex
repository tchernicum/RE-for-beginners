\subsection{Simple example}

\lstinputlisting[style=customc]{patterns/04_scanf/1_simple/ex1.c}

最近、ユーザーとのやり取りに \scanf を使用するのは賢明ではありません。 
しかし、 \Tint 型の変数にポインタを渡す例で説明することができます。

\subsubsection{ポインタについて}
\myindex{\CLanguageElements!\Pointers}

ポインタはコンピュータサイエンスの基本概念の1つです。
多くの場合、大規模な配列、構造体またはオブジェクトを引数として別の関数に渡すことはコストがかかりすぎ、アドレスを渡すことはずっと安いです。
たとえば、コンソールにテキスト文字列を印刷する場合、そのアドレスを\ac{OS}カーネルに渡す方がはるかに簡単です。

さらに、\gls{callee}関数が大きな配列または構造体の中の何かをパラメータとして受け取って構造体全体を返す必要がある場合、状況は不条理に近いです。
したがって、配列や構造体のアドレスを呼び出し先関数に渡し、変更する必要のあるものを変更させるのが最も簡単です。

\CCpp のポインタは、単純にあるメモリ位置のアドレスです。

\myindex{x86-64}
x86では、アドレスは32ビット数（すなわち、4バイトを占める）で表され、x86-64では64ビット数（8バイトを占める）です。
ところで、それがx86-64への切り替えに関連する憤慨の裏にある理由は、x64アーキテクチャのポインタは、「高価な」メモリであるキャッシュメモリを含めて、2倍のスペースを必要とします。

% TODO ... а делать разные версии memcpy для разных типов - абсурд
\myindex{\CStandardLibrary!memcpy()}
何らかの努力があれば、型の指定されていないポインタでのみ作業することができます。例えば1つのメモリ位置から別のメモリ位置にブロックをコピーする標準のC関数\TT{memcpy()}は、
コピーするデータの型を予測することが不可能なため、\TT{void*}型の2つのポインタを引数としてとります。データ型は重要ではなく、ブロックサイズだけが重要です。

ポインタは、関数が複数の値を返す必要がある場合にも広く使用されます。
（これについては後で説明します:~(\myref{label_pointers})）

\scanf 関数が、このような場合です。

関数が正常に読み取られた値の数を示す必要があるという事実に加えて、これらの値もすべて返す必要があります。

\CCpp では、ポインタ型はコンパイル時の型チェックにのみ必要です。

内部的には、コンパイルされたコードには、ポインタ型に関する情報はまったくありません。
% TODO это сильно затрудняет декомпиляцию

\input{patterns/04_scanf/1_simple/x86}
\input{patterns/04_scanf/1_simple/x64}
\input{patterns/04_scanf/1_simple/ARM}
\input{patterns/04_scanf/1_simple/MIPS/main}
