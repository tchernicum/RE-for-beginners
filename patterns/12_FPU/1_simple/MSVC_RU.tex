\myparagraph{MSVC}

Компилируем в MSVC 2010:

\lstinputlisting[caption=MSVC 2010: \ttf{},style=customasmx86]{patterns/12_FPU/1_simple/MSVC_RU.asm}

\FLD берет 8 байт из стека и загружает их в регистр \ST{0}, автоматически конвертируя во внутренний 
80-битный формат (\emph{extended precision}).

\myindex{x86!\Instructions!FDIV}
\FDIV делит содержимое регистра \ST{0} на число, лежащее по адресу \GTT{\_\_real@40091eb851eb851f}~--- 
там закодировано значение 3,14. Синтаксис ассемблера не поддерживает подобные числа, 
поэтому мы там видим шестнадцатеричное представление числа 3,14 в формате IEEE 754.

После выполнения \FDIV в \ST{0} остается \glslink{quotient}{частное}.

\myindex{x86!\Instructions!FDIVP}
Кстати, есть ещё инструкция \FDIVP, которая делит \ST{1} на \ST{0}, 
выталкивает эти числа из стека и заталкивает результат. 
Если вы знаете язык Forth\FNURLFORTH, то это как раз оно и есть~--- стековая машина\FNURLSTACK.

Следующая \FLD заталкивает в стек значение $b$.

После этого в \ST{1} перемещается результат деления, а в \ST{0} теперь $b$.

\myindex{x86!\Instructions!FMUL}
Следующий \FMUL умножает $b$ из \ST{0} на значение \\
\GTT{\_\_real@4010666666666666} --- там лежит число 4,1~--- и оставляет результат в \ST{0}.

\myindex{x86!\Instructions!FADDP}
Самая последняя инструкция \FADDP складывает два значения из вершины стека 
в \ST{1} и затем выталкивает значение, лежащее в \ST{0}. 
Таким образом результат сложения остается на вершине стека в \ST{0}.

Функция должна вернуть результат в \ST{0}, так что больше ничего здесь не производится, 
кроме эпилога функции.

\input{patterns/12_FPU/1_simple/olly_RU.tex}
