float_rand:

var_10          = -0x10
var_4           = -4

                lui     $gp, (__gnu_local_gp >> 16)
                addiu   $sp, -0x20
                la      $gp, (__gnu_local_gp & 0xFFFF)
                sw      $ra, 0x20+var_4($sp)
                sw      $gp, 0x20+var_10($sp)
; Aufruf von my_rand():
                jal     my_rand
                or      $at, $zero ; branch delay slot, NOP
; \$v0=32-bit Pseudozufallswert
                li      $v1, 0x7FFFFF
; \$v1=0x7FFFFF
                and     $v1, $v0, $v1
; \verb|$v1=Pseudozufallswert & 0x7FFFFF|
                lui     $a0, 0x3F80
; \$a0=0x3F800000
                or      $v1, $a0
; \verb!$v1=Pseudozufallswert & 0x7FFFFF | 0x3F800000!
; der Zweck des folgenden Befehls ist schwer zu verstehen
                lui     $v0, ($LC0 >> 16)
; lade 1.0 nach \$f0:
                lwc1    $f0, $LC0
; verschiebe Wert \$v1 zu Koprozessor 1 (in Register \$f2)
; verhält sich wie bitweises Kopieren, Umwandlung findet nicht statt:
                mtc1    $v1, $f2
                lw      $ra, 0x20+var_4($sp)
; subtrahiere 1.0. Lasse Ergebnis in \$f0:
                sub.s   $f0, $f2, $f0
                jr      $ra
                addiu   $sp, 0x20  ; branch delay slot

main:

var_18          = -0x18
var_10          = -0x10
var_C           = -0xC
var_8           = -8
var_4           = -4

                lui     $gp, (__gnu_local_gp >> 16)
                addiu   $sp, -0x28
                la      $gp, (__gnu_local_gp & 0xFFFF)
                sw      $ra, 0x28+var_4($sp)
                sw      $s2, 0x28+var_8($sp)
                sw      $s1, 0x28+var_C($sp)
                sw      $s0, 0x28+var_10($sp)
                sw      $gp, 0x28+var_18($sp)
                lw      $t9, (time & 0xFFFF)($gp)
                or      $at, $zero ; load delay slot, NOP
                jalr    $t9
                move    $a0, $zero ; branch delay slot
                lui     $s2, ($LC1 >> 16)  # \verb|"%f\n"|
                move    $a0, $v0
                la      $s2, ($LC1 & 0xFFFF)  # \verb|"%f\n"|
                move    $s0, $zero
                jal     my_srand
                li      $s1, 0x64  # 'd' ; branch delay slot

loc_104:
                jal     float_rand
                addiu   $s0, 1
                lw      $gp, 0x28+var_18($sp)
; \verb|konvertiere Wert von float_rand() in double (printf() benötigt diesen):|
                cvt.d.s $f2, $f0
                lw      $t9, (printf & 0xFFFF)($gp)
                mfc1    $a3, $f2
                mfc1    $a2, $f3
                jalr    $t9
                move    $a0, $s2
                bne     $s0, $s1, loc_104
                move    $v0, $zero
                lw      $ra, 0x28+var_4($sp)
                lw      $s2, 0x28+var_8($sp)
                lw      $s1, 0x28+var_C($sp)
                lw      $s0, 0x28+var_10($sp)
                jr      $ra
                addiu   $sp, 0x28 ; branch delay slot

$LC1:           .ascii "%f\n"<0>
$LC0:           .float 1.0
