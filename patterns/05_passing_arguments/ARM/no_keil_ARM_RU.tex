\subsubsection{\NonOptimizingKeilVI (\ARMMode)}

\lstinputlisting[style=customasmARM]{patterns/05_passing_arguments/ARM/tmp1.asm}

В функции \main просто вызываются две функции, в первую (\ttf) передается три значения.
Как уже было упомянуто, первые 4 значения в ARM обычно передаются в первых 4-х регистрах (\Reg{0}-\Reg{3}).
Функция \ttf, как видно, использует три первых регистра (\Reg{0}-\Reg{2}) как аргументы.

\myindex{ARM!\Instructions!MLA}
Инструкция \TT{MLA} (\emph{Multiply Accumulate}) перемножает два первых операнда (\Reg{3} и \Reg{1}), 
прибавляет к произведению
третий операнд (\Reg{2}) и помещает результат в нулевой регистр (\Reg{0}), через который, по стандарту, 
возвращаются значения функций.

\myindex{Fused multiply–add}
Умножение и сложение одновременно (\emph{Fused multiply–add}) это часто применяемая операция. Кстати, аналогичной
инструкции в x86 не было до появления FMA-инструкций в SIMD
\footnote{\href{http://go.yurichev.com/17103}{wikipedia}}.

Самая первая инструкция \TT{MOV R3, R0}, по-видимому, избыточна (можно было бы обойтись только одной инструкцией \TT{MLA}).
Компилятор не оптимизировал её, ведь, это компиляция без оптимизации.

\myindex{ARM!Переключение режимов}
\myindex{ARM!\Instructions!BX}
Инструкция \TT{BX} возвращает управление по адресу, записанному в \ac{LR} и, если нужно, 
переключает режимы процессора с Thumb на ARM или наоборот.
Это может быть необходимым потому, что, как мы видим, 
функции \ttf неизвестно, из какого кода она будет вызываться, из ARM или Thumb.
Поэтому, если она будет вызываться из кода Thumb, \TT{BX} не только возвращает
управление в вызывающую функцию, но также переключает процессор в режим Thumb.
Либо не переключит, если функция вызывалась из кода для режима ARM: \InSqBrackets{\ARMSevenRef A2.3.2}.

% look for "BXWritePC()" in manual
