\mysection{方法}

この本の著者はC言語、その後Cppを学び始めたとき、小さなコードを書いてコンパイルし、アセンブリ言語の出力を見ていました。 これにより、彼が書いたコードで何が起こっているのかを理解することが非常に容易になりました。\footnote{実際、彼はコードの特定のビットが何をしているのか理解できないときもこれを実行します}
彼はこれを何度もやって、Cppコードとコンパイラが作り出したものとの関係が彼の心の中に深く刻まれていたことを知っています。 今では、Cコードの外観と機能の概要を即座に想像するのは簡単です。 おそらく、このテクニックは他の人に役立つかもしれません。

%There are a lot of examples for both x86/x64 and ARM.
%Those who already familiar with one of architectures, may freely skim over pages.

なお、PCにインストールせずに、さまざまなコンパイラを使ってPCと同じことができる素晴らしいWebサイトがあります。あなたもそれを使うことができます：\url{https://godbolt.org/}

\section*{練習問題}

この本の作者がアセンブリ言語を学んだとき、彼はしばしば小さなC関数をコンパイルしてから、
アセンブリを徐々に書き直してコードを可能な限り短くしようとしました。 効率性の点で最新のコンパイラと競争するのは難しいため、
現実のシナリオではこれはおそらく価値がありません。 しかし、それはアセンブリのより良い理解を得るための非常に良い方法です。 
したがって、この本の中からアセンブリコードを取り出して短くしてみてください。 
しかし、あなたが書いたものをテストすることを忘れないでください。

% rewrote to show that debug\release and optimisations levels are orthogonal concepts.
\section*{最適化レベルとデバッグ情報}

ソースコードはさまざまな最適化レベルを持つ異なるコンパイラによってコンパイルできます。
典型的なコンパイラにはこのようなレベルが約3つあります。レベル0は最適化が完全に無効になっていることを意味します。
最適化は、コードサイズやコードの速度に合わせることもできます。最適化されていないコンパイラはより高速でより理解しやすいコードを生成しますが、
最適化コンパイラは遅くなり、実行速度の速いコードを生成しようとします（コンパクトである必要はありません）。
最適化レベルに加えて、コンパイラは結果ファイルにいくつかのデバッグ情報を含めて、デバッグしやすいコードを生成することができます。
「デバッグ」コードの重要な機能の1つは、ソースコードの各行とそれぞれのマシンコードアドレスとの間にリンクを含む可能性があることです。
一方、コンパイラを最適化すると、ソースコードの行全体が最適化され、結果のマシンコードにも存在しない出力が生成される傾向があります。
リバースエンジニアはいずれかのバージョンに遭遇する可能性があります。
なぜなら、一部の開発者はコンパイラの最適化フラグをオンにし、他の開発者はそうしないからですこのため、
可能であれば、本書に記載されているコードのデバッグ版とリリース版の両方の例を取り上げようとします。

最も短い（または最も単純な）コードスニペットを得るために、時にはかなり古いコンパイラがこの本で使われています。
