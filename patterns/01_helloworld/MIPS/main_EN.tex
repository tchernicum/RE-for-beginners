\subsection{MIPS}

\subsubsection{A word about the \q{global pointer}}
\label{MIPS_GP}

\myindex{MIPS!\GlobalPointer}

One important MIPS concept is the \q{global pointer}.
As we may already know, each MIPS instruction has a size of 32 bits, so it's impossible to embed a 32-bit
address into one instruction: a pair has to be used for this 
(like GCC did in our example for the text string address loading).
It's possible, however, to load data from the address in the range of $register-32768...register+32767$ using one
single instruction (because 16 bits of signed offset could be encoded in a single instruction).
So we can allocate some register for this purpose and also allocate a 64KiB area of most used data.
This allocated register is called a \q{global pointer} and it points to the middle of the 64KiB area.
This area usually contains global variables and addresses of imported functions like \printf, 
because the GCC developers decided that getting the address of some function must be as fast as a single instruction
execution instead of two.
In an ELF file this 64KiB area is located partly in sections .sbss (\q{small \ac{BSS}}) for uninitialized data and 
.sdata (\q{small data}) for initialized data.
This implies that the programmer may choose what data he/she wants to be accessed fast and place it into 
.sdata/.sbss.
Some old-school programmers may recall the MS-DOS memory model \myref{8086_memory_model} 
or the MS-DOS memory managers like XMS/EMS where all memory was divided in 64KiB blocks.

\myindex{PowerPC}

This concept is not unique to MIPS. At least PowerPC uses this technique as well.

\subsubsection{\Optimizing GCC}

Let's consider the following example, which illustrates the \q{global pointer} concept.

\lstinputlisting[caption=\Optimizing GCC 4.4.5 (\assemblyOutput),numbers=left,style=customasmMIPS]{patterns/01_helloworld/MIPS/hw_O3_EN.s}

As we see, the \$GP register is set in the function prologue to point to the middle of this area.
The \ac{RA} register is also saved in the local stack.
\puts is also used here instead of \printf.
\myindex{MIPS!\Instructions!LW}
The address of the \puts function is loaded into \$25 using \INS{LW} the instruction (\q{Load Word}).
\myindex{MIPS!\Instructions!LUI}
\myindex{MIPS!\Instructions!ADDIU}
Then the address of the text string is loaded to \$4 using \INS{LUI} (\q{Load Upper Immediate}) and 
\INS{ADDIU} (\q{Add Immediate Unsigned Word}) instruction pair.
\INS{LUI} sets the high 16 bits of the register (hence \q{upper} word in instruction name) and \INS{ADDIU} adds
the lower 16 bits of the address.

\INS{ADDIU} follows \INS{JALR} (haven't you forgot \emph{branch delay slots} yet?).
The register \$4 is also called \$A0, which is used for passing the first function argument
\footnote{The MIPS registers table is available in appendix \myref{MIPS_registers_ref}}.

\myindex{MIPS!\Instructions!JALR}

\INS{JALR} (\q{Jump and Link Register}) jumps to the address stored in the \$25 register (address of \puts) 
while saving the address of the next instruction (LW) in \ac{RA}.
This is very similar to ARM.
Oh, and one important thing is that the address saved in \ac{RA} is not the address of the next instruction (because
it's in a \emph{delay slot} and is executed before the jump instruction),
but the address of the instruction after the next one (after the \emph{delay slot}).
Hence, $PC + 8$ is written to \ac{RA} during the execution of \TT{JALR}, in our case, this is the address of the \INS{LW}
instruction next to \INS{ADDIU}.

\INS{LW} (\q{Load Word}) at line 20 restores \ac{RA} from the local stack (this instruction is actually part of the function epilogue).

\myindex{MIPS!\Pseudoinstructions!MOVE}

\INS{MOVE} at line 22 copies the value from the \$0 (\$ZERO) register to \$2 (\$V0).
\label{MIPS_zero_register}

MIPS has a \emph{constant} register, which always holds zero.
Apparently, the MIPS developers came up with the idea that zero is in fact the busiest constant in the computer programming,
so let's just use the \$0 register every time zero is needed.

Another interesting fact is that MIPS lacks an instruction that transfers data between registers.
In fact, \TT{MOVE DST, SRC} is \TT{ADD DST, SRC, \$ZERO} ($DST=SRC+0$), which does the same.
Apparently, the MIPS developers wanted to have a compact opcode table.
This does not mean an actual addition happens at each \INS{MOVE} instruction.
Most likely, the \ac{CPU} optimizes these pseudo instructions and the \ac{ALU} is never used.

\myindex{MIPS!\Instructions!J}

\INS{J} at line 24 jumps to the address in \ac{RA}, which is effectively performing a return from the function.
\INS{ADDIU} after \INS{J} is in fact executed before \INS{J} (remember \emph{branch delay slots}?) and is part of the function epilogue.
Here is also a listing generated by \IDA. Each register here has its own pseudo name:

\lstinputlisting[caption=\Optimizing GCC 4.4.5 (\IDA),numbers=left,style=customasmMIPS]{patterns/01_helloworld/MIPS/hw_O3_IDA_EN.lst}

The instruction at line 15 saves the GP value into the local stack, and this instruction is missing mysteriously from the GCC output listing, maybe by a GCC error
\footnote{Apparently, functions generating listings are not so critical to GCC users, so some unfixed cosmetic bugs may still exist.}.
The GP value has to be saved indeed, because each function can use its own 64KiB data window.
The register containing the \puts address is called \$T9, because registers prefixed with T- are called
\q{temporaries} and their contents may not be preserved.

\subsubsection{\NonOptimizing GCC}

\NonOptimizing GCC is more verbose.

\lstinputlisting[caption=\NonOptimizing GCC 4.4.5 (\assemblyOutput),numbers=left,style=customasmMIPS]{patterns/01_helloworld/MIPS/hw_O0_EN.s}

We see here that register FP is used as a pointer to the stack frame.
We also see 3 \ac{NOP}s.
The second and third of which follow the branch instructions.
Perhaps the GCC compiler always adds \ac{NOP}s (because of \emph{branch delay slots}) after branch
instructions and then, if optimization is turned on, maybe eliminates them.
So in this case they are left here.

Here is also \IDA listing:

\lstinputlisting[caption=\NonOptimizing GCC 4.4.5 (\IDA),numbers=left,style=customasmMIPS]{patterns/01_helloworld/MIPS/hw_O0_IDA_EN.lst}

\myindex{MIPS!\Pseudoinstructions!LA}

Interestingly, \IDA recognized the \INS{LUI}/\INS{ADDIU} instructions pair and coalesced them into one 
\INS{LA} (\q{Load Address}) pseudo instruction at line 15.
We may also see that this pseudo instruction has a size of 8 bytes!
This is a pseudo instruction (or \emph{macro}) because it's not a real MIPS instruction, but rather
a handy name for an instruction pair.

\myindex{MIPS!\Pseudoinstructions!NOP}
\myindex{MIPS!\Instructions!OR}

Another thing is that \IDA doesn't recognize \ac{NOP} instructions, so here they are at lines 22, 26 and 41.
It is \TT{OR \$AT, \$ZERO}.
Essentially, this instruction applies the OR operation to the contents of the \$AT register
with zero, which is, of course, an idle instruction.
MIPS, like many other \ac{ISA}s, doesn't have a separate \ac{NOP} instruction.

\subsubsection{Role of the stack frame in this example}

The address of the text string is passed in the register.
Why setup a local stack anyway?
The reason for this lies in the fact that the values of registers \ac{RA} and GP have to be saved somewhere 
(because \printf is called), and the local stack is used for this purpose.
If this was a \gls{leaf function}, it would have been possible to get rid of the function prologue and epilogue,
for example: \myref{MIPS_leaf_function_ex1}.

\subsubsection{\Optimizing GCC: load it into GDB}

\myindex{GDB}
\lstinputlisting[caption=sample GDB session]{patterns/01_helloworld/MIPS/O3_GDB.txt}

