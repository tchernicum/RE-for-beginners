\subsection{簡単なCPU入門}

\ac{CPU}は、プログラムが構成するマシンコードを実行するデバイスです。

\textbf{短い用語集}

\begin{description}
\item[命令]: プリミティブ\ac{CPU}コマンド。
最も単純な例としては、レジスタ間のデータの移動、メモリの操作、プリミティブ算術演算などがあります。 一般に、各CPUには独自の命令セットアーキテクチャ（ISA）があり、
\item[マシンコード]: CPUが直接処理するコード。 各命令は、通常、数バイトで符号化されます。
\item[アセンブリ言語]: ニーモニックコードと、マクロのようないくつかの拡張機能は、プログラマーの人生をより簡単にするためのものです。
\item[CPUレジスタ]: 各CPUには汎用レジスタ（GPR）の固定セットがあります。 x86では約8、x86-64では約16、ARMでは約16です。 レジスタを理解する最も簡単な方法は、それを型なしの一時変数と考えることです。 高水準のPLで作業していて、8つの32ビット（または64ビット）変数しか使用できないとしたらどうでしょうか？ しかし、これらを使って多くのことを行うことができます！
\end{description}

% TODO1 add about linker: "компоновщик" и "редактор связей" в русскоязычной лит-ре

% A note on the experiments in this area (like the LISP machines http://en.wikipedia.org/wiki/Lisp_machine
% might be useful
機械コードとPLの違いが必要な理由は不思議です。 答えは、人間とCPUが似ていないという事実にあります。人間がCpp、Java、Pythonなどの高レベルのPLを使う方がはるかに簡単ですが、CPUがはるかに低いレベルを使用する方が簡単です。抽象化のおそらく、高レベルのPLコードを実行できるCPUを発明することは可能かもしれませんが、今日われわれが知っているCPUの何倍も複雑なものになるでしょう。 同様の方法で、人間がアセンブリ言語で書くことは非常に不便です。なぜなら、それは低レベルであり、厄介な間違いを大量に作成することなく書き込むことが難しいからです。 上位PLコードをアセンブリに変換するプログラムをコンパイラと呼びます。
\footnote{旧式のロシア文学でも、翻訳者という用語が使われています。}

\myindex{ARM!\ARMMode}%
\myindex{ARM!\ThumbMode}%
\myindex{ARM!\ThumbTwoMode}%

\subsubsection{異なる \ac{ISA}s について2、3}
x86 \ac{ISA}は常に可変長命令を持っていたので、64ビット時代になるとx64拡張は\ac{ISA}に非常に大きな影響を与えませんでした。実際、x86 \ac{ISA}には、16ビットの8086 CPUに最初に登場した命令がまだ多く含まれていますが、今日のCPUではまだ見つかっています。 ARMは一定の長さの命令を念頭に置いて設計された\ac{RISC} \ac{CPU}であり、過去にいくつかの利点がありました。当初、すべてのARM命令は4バイトでエンコードされていました
\footnote{固定長命令は、労力を要することなく次（または前）の命令アドレスを計算できるため、便利です。この機能については、switch（）オペレータセクションで説明します。}
これは現在、\q{ARMモード}と呼ばれています。それから、彼らは最初に想像したほど倹約的ではないことに気付きました。
実際のアプリケーションで最も一般的な\ac{CPU}命令（MOV/PUSH/CALL/Jccなど）は、より少ない情報を使用してエンコードできます。
したがって、Thumbと呼ばれる別の\ac{ISA}を追加しました。そこでは、各命令はわずか2バイトでエンコードされていました。
これを\q{Thumbモード}と呼びます。ただし、すべてのARM命令が2バイトでエンコードできるわけではないため、Thumb命令セットは多少制限されています。 
ARMモードとThumbモード用にコンパイルされたコードは、1つのプログラム内で共存できることに注意してください。 
ARMの作成者は、Thumbを拡張して、ARMv7に登場したThumb-2を生み出すことができると考えました。 
Thumb-2はまだ2バイトの命令を使用しますが、4バイトのサイズを持ついくつかの新しい命令があります。 
Thumb-2はARMとThumbが混在しているという誤解が一般的です。これは間違っています。
むしろThumb-2はすべてのプロセッサ機能を完全にサポートするように拡張されており、ARMモードと競合する可能性があります。
これは明らかに達成された目標で、\ idevicesの大部分のアプリケーションはThumb-2命令セット用にコンパイルされています。 
（確かに、これは主にXcodeがデフォルトで行うためです）。後で64ビットARMが出ました。この\ac{ISA}には4バイトの命令があり、
Thumbモードを追加する必要はありませんでした。しかし、64ビットの要件が\ac{ISA}に影響を与え、ARMモード、Thumbモード（Thumb-2を含む）、
ARM64という3つのARM命令セットを持つようになりました。これらの\ac{ISA}は部分的に交差するが、同じ\ac{ISA}であると言える。
したがって、この本では3つのARM \ac{ISA}すべてにコードの断片を追加しようとします。
ところで、
\myindex{PowerPC}%
\myindex{MIPS}%
\myindex{Alpha AXP}%
MIPS、PowerPC、Alpha AXPなど固定長の32ビット命令を持つ他の多くの\ac{RISC} \ac{ISA}があります。
