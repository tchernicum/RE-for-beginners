\subsection{\CapitalPICcode}
\myindex{\PICcode}
\myindex{Linux}
\label{sec:PIC}

Во время анализа динамических библиотек (.so) в Linux, часто можно заметить такой шаблонный код:

\lstinputlisting[style=customasmx86,caption=libc-2.17.so x86]{OS/tmp1.asm}

Все указатели на строки корректируются при помощи некоторой константы из регистра \EBX, которая вычисляется в начале каждой функции.

Это так называемый адресно-независимый код (\ac{PIC}), он предназначен для исполнения будучи расположенным по любому адресу в памяти, вот почему он не содержит никаких абсолютных адресов в памяти.

\ac{PIC} был очень важен в ранних компьютерных системах и важен сейчас во встраиваемых\footnote{embedded}, не имеющих поддержки виртуальной памяти (все процессы расположены в одном непрерывном блоке памяти).
Он до сих пор используется в *NIX системах для динамических библиотек, потому что динамическая библиотека может использоваться одновременно в нескольких процессах, будучи загружена в память только один раз.
Но все эти процессы могут загрузить одну и ту же динамическую библиотеку по разным адресам, вот почему динамическая библиотека должна работать корректно, не привязываясь к абсолютным адресам.

Простой эксперимент:

\begin{lstlisting}[style=customc]
#include <stdio.h>

int global_variable=123;

int f1(int var)
{
    int rt=global_variable+var;
    printf ("returning %d\n", rt);
    return rt;
};
\end{lstlisting}

Скомпилируем в GCC 4.7.3 и посмотрим итоговый файл .so в \IDA:

\begin{lstlisting}
gcc -fPIC -shared -O3 -o 1.so 1.c
\end{lstlisting}

\lstinputlisting[style=customasmx86,caption=GCC 4.7.3]{OS/tmp2.asm}

\newcommand{\retstring}{\emph{<<returning \%d\textbackslash{}n>>}}
\newcommand{\globvar}{\emph{global\_variable}}

Так и есть: указатели на строку \retstring{} и переменную \globvar{} корректируются при каждом исполнении функции.

\par Функция \TT{\_\_x86\_get\_pc\_thunk\_bx()} возвращает адрес точки после вызова самой себя (здесь: \TT{0x57C}) в \EBX.
Это очень простой способ получить значение указателя на текущую инструкцию (\EIP) в произвольном месте.

Константа \TT{0x1A84} связана с разницей между началом этой функции и так называемой
\emph{Global Offset Table Procedure Linkage Table} (GOT PLT), секцией, сразу же за \emph{Global Offset Table} (GOT), где находится указатель на \globvar{}.
\IDA показывает смещения уже обработанными, чтобы их было проще понимать, но на самом деле код такой:

\begin{lstlisting}[style=customasmx86]
.text:00000577                 call    __x86_get_pc_thunk_bx
.text:0000057C                 add     ebx, 1A84h
.text:00000582                 mov     [esp+1Ch+var_4], esi
.text:00000586                 mov     eax, [ebx-0Ch]
.text:0000058C                 mov     esi, [eax]
.text:0000058E                 lea     eax, [ebx-1A30h]
\end{lstlisting}

Так что, \EBX указывает на секцию \TT{GOT PLT} и для вычисления указателя на \globvar{}, которая хранится в \TT{GOT}, нужно вычесть 0xC.
А чтобы вычислить указатель на \retstring{}, нужно вычесть \TT{0x1A30}.

\myindex{x86-64}
\myindex{x86!\Registers!RIP}
Кстати, вот зачем в AMD64 появилась поддержка адресации относительно RIP\footnote{указатель инструкций в AMD64}, просто для упрощения PIC-кода.

Скомпилируем тот же код на Си при помощи той же версии GCC, но для x64.

\myindex{objdump}
\IDA упростит код на выходе убирая упоминания RIP, так что будем использовать \emph{objdump} вместо нее:

\lstinputlisting[style=customasmx86]{OS/tmp3.asm}

\TT{0x2008b9} это разница между адресом инструкции по \TT{0x720} и \globvar{}, 
а \TT{0x20} это разница между инструкцией по \TT{0x72A} и строкой \retstring{}.

Как видно, необходимость очень часто пересчитывать адреса делает исполнение немного медленнее 
(хотя это и стало лучше в x64).
Так что если вы заботитесь о скорости исполнения, то, наверное, нужно задуматься о статической компоновке (static linking)
\InSqBrackets{см. \AgnerFogCPP}.

\subsubsection{Windows}
\myindex{Windows!Win32}

Такой механизм не используется в Windows DLL. Если загрузчику в Windows приходится загружать DLL 
в другое место, он \q{патчит} DLL прямо в памяти (на местах \emph{FIXUP}-ов) чтобы скорректировать 
все адреса.
Это приводит к тому что загруженную один раз DLL нельзя использовать одновременно в разных 
процессах, желающих расположить её по разным адресам --- потому что каждый загруженный в память 
экземпляр DLL \emph{доводится} до того чтобы работать только по этим адресам.

