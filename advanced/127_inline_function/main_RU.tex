\mysection{Inline-функции}
\myindex{Inline code}
\label{inline_code}

Inline-код это когда компилятор, вместо того чтобы генерировать инструкцию вызова небольшой функции,
просто вставляет её тело прямо в это место.

\lstinputlisting[caption=Простой пример,style=customc]{\CURPATH/1.c}

\dots это компилируется вполне предсказуемо, хотя, если включить оптимизации GCC (\Othree), мы увидим:

\lstinputlisting[caption=\Optimizing GCC 4.8.1,style=customasmx86]{\CURPATH/1.s}

(Здесь деление заменено умножением(\myref{sec:divisionbymult}).)

Да, наша маленькая функция \TT{celsius\_to\_fahrenheit()} была помещена прямо перед вызовом \printf.

Почему? Это может быть быстрее чем исполнять код самой функции плюс затраты на вызов и возврат.

Современные оптимизирующие компиляторы самостоятельно выбирают функции для вставки.
Но компилятор можно дополнительно принудить развернуть некоторую функцию, 
если маркировать её ключевым словом \q{inline} в её определении.

% sections
\input{\CURPATH/str_mem/main}
