\subsection{Exploitation de chaîne de format}

Il y a une erreur courante, celle d'écrire \TT{printf(string)} au lieu de \TT{puts(string)}
ou \TT{printf("\%s", string)}.
Si l'attaquant peut mettre son propre texte dans \TT{string}, il peut planter le
processus ou accéder aux variables de la pile locale.

Regardons ceci:

\lstinputlisting[style=customc]{\CURPATH/f.c}

Veuillez noter que \printf n'a pas d'argument supplémentaire autre que la chaîne
de format.

Maintenant, imaginons que c'est l'attaquant qui a mis la chaîne \TT{\%s} dans le
premier argument du dernier \printf.
Je compile cet exemple en utilisant GCC 5.4.0 sous Ubuntu x86, et l'exécutable résultant
affiche la chaîne \q{world} s'il est exécuté!

Si je compile avec l'optimisation, \printf affiche n'importe quoi, aussi---probablement,
l'appel à strcpy() a été optimisé et/ou les variables locales également.
De même, le résultat pour du code x64 sera différent, pour différents compilateurs,
\ac{OS}, etc.

Maintenant, disons que l'attaquant peut passer la chaîne suivante à l'appel de \printf:
\TT{\%x \%x \%x \%x \%x}.
Dans mon cas, la sortie est: \q{80485c6 b7751b48 1 0 80485c0} (ce sont simplement
des valeurs de la pile locale).
Vous voyez, il y a les valeurs 1 et 0, et des pointeurs (le premier est probablement
un pointeur sur la chaîne \q{world}).
Donc si l'attaquant passe la chaîne \TT{\%s \%s \%s \%s \%s}, le processus va se
planter, car \printf traite 1 et/ou 0 comme des pointeurs sur une chaîne, essaye
de lire des caractères et échoue.

Encore pire, il pourrait y avoir \TT{sprintf (buf, string)} dans le code, où \TT{buf}
est un buffer dans la pile locale avec un taille de 1024 octets ou autre, l'attaquant
pourrait préparer une \TT{chaîne} de telle sorte que \TT{buf} serait débordé, peut-être
même de façon à conduire à l'exécution de code.

De nombreux logiciels bien connus et très utilisés étaient (ou sont encore) vulnérables:

\myindex{Quake}
\myindex{John Carmack}
\begin{framed}
\begin{quotation}
QuakeWorld went up, got to around 4000 users, then the master server exploded.\\
(QuakeWorld est arrivé, monté à environ 4000 utilisateurs, puis le serveur master a explosé.)

Disrupter and cohorts are working on more robust code now.\\
(Les perturbateurs et cohortes travaillent maintenant sur un code plus robuste.)

If anyone did it on purpose, how about letting us know... (It wasn't all the people that tried \%s as a name)\\
(Si quelqu'un l'a fait exprès, pourquoi ne pas nous le faire savoir... (Ce n'est pas tout le monde qui a essayé \%s comme nom))
\end{quotation}
\end{framed}
( John Carmack's .plan file, 17-Dec-1996\footnote{\url{https://github.com/ESWAT/john-carmack-plan-archive/blob/33ae52fdba46aa0d1abfed6fc7598233748541c0/by_day/johnc_plan_19961217.txt}} )

De nos jours, tous les compilateurs dignes de ce nom avertissent à propos de ceci.

Un autre problème qui est moins connu, c'est l'argument \TT{\%n} de \printf: lorsque
\printf l'atteint dans la chaîne de format, il écrit le nombre de caractères écrits
jusqu'ici dans l'argument correspondant:
\url{http://stackoverflow.com/questions/3401156/what-is-the-use-of-the-n-format-specifier-in-c}.
Ainsi, un attaquant peut zapper les variables locales en passant plusieurs commandes
\TT{\%n} dans la chaîne de format.
