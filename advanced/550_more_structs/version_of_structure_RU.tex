\subsection{Версия структуры в Си}

Многие программисты под Windows видели это в MSDN:

\begin{lstlisting}
SizeOfStruct
    The size of the structure, in bytes. This member must be set to sizeof(SYMBOL_INFO).
\end{lstlisting}

( \url{https://msdn.microsoft.com/en-us/library/windows/desktop/ms680686(v=vs.85).aspx} )

Некоторые структуры вроде \emph{SYMBOL\_INFO} действительно начинаются с такого поля. Почему?
Это что-то вроде версии структуры.

Представьте, что у вас есть ф-ция, рисующая круги.
Она берет один аргумент - указатель на структуру с двумя полями: X, Y и радиус.
И затем цветные дисплеи наводнили рынок, где-то в 80-х. И вы хотите добавить аргумент \emph{цвет} в ф-цию.
Но, скажем так, вы не можете добавить еще один аргумент в нее (множество ПО используют ваше \ac{API} и его нельзя
перекомпилировать).
И если какое-то старое ПО использует ваше \ac{API} с цветным дисплеем,
пусть ваша ф-ция рисует круг в цветах по умолчанию (черный и белый).

Позже вы добавляете еще одну возможность: круг может быть закрашен, и можно выбирать тип заливки.

Вот одно из решений проблемы:

\lstinputlisting[style=customc]{advanced/550_more_structs/src_RU.c}

Другими словами, поле \emph{SizeOfStruct} берет на себя роль поля \emph{версия структуры}.
Это может быть перечисляемый тип (1, 2, 3, итд.), но установка поля \emph{SizeOfStruct} равным \emph{sizeof(struct...)},
это лучше защищено от ошибок: в вызываемом коде мы просто пишем \emph{s.SizeOfStruct=sizeof(...)}.

В Си++ эта проблема решается \emph{наследованием} (\myref{cpp_inheritance}).
Просто расширяете ваш базовый класс (назовем его \emph{Circle}),
и затем вам нужен \emph{ColoredCircle}, а потом \emph{FilledColoredCircle}, и так далее.
Текущая \emph{версия} объекта (или более точно, текущий \emph{тип}) будет определяться при помощи \ac{RTTI} в Си++.

Так что если вы где-то в \ac{MSDN} видите \emph{SizeOfStruct} --- вероятно, эта структура уже расширялась в прошлом,
как минимум один раз.

