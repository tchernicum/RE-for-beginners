\subsection{Память}

Иногда вы можете услышать от программистов на Си++ \q{выделить память на/в стеке} и/или \q{выделить память в \glslink{heap}{куче}}.

Выделение памяти \emph{на стеке}:

\begin{lstlisting}[style=customc]
void f()
{
	...

	Class o=Class(...);

	...
};
\end{lstlisting}

Память для объекта (или структуры) выделяется в стеке, при помощи простого сдвига \ac{SP}.
Память освобождается во время выхода из ф-ции, или, более точно, в конце \emph{области видимости} (\emph{scope})---\ac{SP}
возвращается в своё состояние (такое же, как при старте ф-ции) и вызывается деструктор класса \emph{Class}.
В такой же манере, выделяется и освобождается память для структуры в Си.

Выделение памяти для объекта \emph{в \glslink{heap}{куче}}:

\begin{lstlisting}[style=customc]
void f1()
{
	...

	Class *o=new Class(...);

	...
};

void f2()
{
	...

	delete o;

	...
};
\end{lstlisting}

\myindex{\CStandardLibrary!malloc()}
\myindex{\CStandardLibrary!free()}
Это то же самое, как и выделять память для структуры используя ф-цию \emph{malloc()}.
На самом деле, \emph{new} в Си++ это \emph{wrapper} для \emph{malloc()}, а \emph{delete} это \emph{wrapper} для \emph{free()}.
Т.к., блок памяти был выделен в \glslink{heap}{куче}, он должен быть освобожден явно, используя \emph{delete}.
Деструктор класса будет автоматически вызван прямо перед этим моментом.

Какой метод лучше?
Выделение \emph{на стеке} очень быстрое и подходит для маленьких объектов с коротким сроком жизни, которые будут использоваться
только в текущей ф-ции.

Выделение \emph{в куче} медленнее, и лучше для объектов с долгим сроком жизни, которые будут использоваться в нескольких
(или многих) ф-циях.
Также, объекты выделенные в \glslink{heap}{куче} подвержены утечкам памяти, потому что их нужно освобождать явно, но об этом
легко забыть.

Так или иначе, это дело вкуса.
